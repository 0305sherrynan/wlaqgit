# 利用异或运算实现加解密作业
## 1.使用语言 JAVA ；工具 IntelliJ IDEA Community Edition 2022.2.1
## 2.算法基本原理
为什么一个数字在通过两次与同一数字key进行异或运算后，依然能得到原来的数字?又因为因为计算机中每个数字都是使用二进制进行存储的，计算机中数与数之间的运算就是二进制位于二进制位的运算。所以我们可以再次对该问题进行简化得到，为什么一位数字与同一位数字进行两次二进制运算将得到原位数字呢?
我们可以用真值表来解答：可以看到经过两次异步确实可以得到原先的结果，因此我们基于此特性，将第一次操作作为加密，第二次作为解密。
| 做左操作数|右操作数|第一次结果|第二次结果） |
| :-----| :---- |:---- | :----|
| 1|1 | 0|1
|  1|0| 1|1
|0|1|1|0
|0|0|0|0
## 3.界面截图
###使用命令行界面进行简单的算法模拟
- 输入依次为 密钥 加密的文件名 输出结果的文件名
![Alt](./img/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.png)
- 由于不管是加密还是解密，用到的算法是一致的，所以不需要用户选择加密还是解密
## 4.输出结果截图
- 我们把读/写的文件放在该目录下
![Alt](./img/%E4%BD%8D%E7%BD%AE.png)
- sourse.txt存放读的内容；change.txt存放写的内容
![Alt](./img/%E4%BD%8D%E7%BD%AE2.png)
### 开始加密
- 我们开始在sourse.txt中存入以下内容
![Alt](./img/%E5%8E%9F.png)
- 运行代码，后查看change.txt，可以看到成功加密
![Alt](./img/%E5%8A%A0%E5%AF%86.png)
###  进行解密
- 我们复制change.txt的内容到sourse.txt
![Alt](./img/%E8%A7%A3%E5%AF%86%E5%89%8D.png)
- 再次运行代码，查看change.txt，发现解密成功
![Alt](./img/%E8%A7%A3%E5%AF%86%E6%88%90%E5%8A%9F.png)
